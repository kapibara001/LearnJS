/**
 * Во время изучения JS я уже встречался с синтаксисом деструктуризации
 * Это возможность присвоения массива или объекта набору переменных, разбив его на 
 * набор частей
 * 
 * let [переменная] = имя массива
 * 
 * let arr = [7, 8, 1]
 *      a = 8, b = 8, c = 1
 * let [a, b, c] = arr
 */


/**
 * Так же при деструктуризации можно использовать spread оператор(...arr)
 * Если он указан, значит в переменую после него нужно записать все оставшиеся элементы массива справа 
 * от знака равенства
 * 
 * let arr = [7, 8, 1]
 * 
 *  // f = 7, 
 *  // arr2 = [8, 1]
 * 
 * let [f, ...arr2] = arr // мы как бы создали переменные f и arr2, где в f 
 * хранится 7, а в arr2 все то, что после 7 - то есть 8, 1
 */


/**
 * Деструктуризация используется и при работе с объектами. При работе с объектами 
 * нужно использовать {} вместо [].
 * 
 * let obj = {name:"Bill", lastName:"White"}; 
 * let {name,lastName} = obj;
 * 
 * 
 * Можно использовать конструкции по типу:
 * let person = {name: 'asd', lastname: 'asd', second: 'qsdqd'}
 * let {name, ...any} = person
 * 
 * return ( {any.second} ) // Это же у нас объект, что нам мешает так сделать, правильно?
 * 
 * 
 * Если мы хотим, чтобы наши переменные имели отличные названия от переменных: 
 * let {name: n, lastname: l} = person
 * // с деструктуризированными данными так не получится
 */



export function Destruct() {
    let arr = [1, 6, 8, 1];
    let arr3 = [6, 1, 76, 2, 67, 2]
    let [f, c, ...arr2] = arr3; // number, number, object
    // return (
    //     <>
    //         <h1>{f}</h1>
    //         <h2>{arr2}</h2>
    //     </>
    // )
    

    let person = {name: 'Billy', lastname: 'Harington', secondname: 'Asdaw'}
    let {name: n, ...any} = person;
    return (
        <div>
            <h1>{any.secondname}</h1> {/*  Так тоже можно */}
        </div>
    )



}