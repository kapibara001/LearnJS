
import { useEffect, useState, useRef } from "react"

let renderCount = 1; 
/* Когда переменная находится вне компонента, это не очень хорошо, но в данном случае так надо,
 т.к компонент у нас будет перендериваться и значение будет всегда = 1. Чтобы не столкнуться с такой ситуацией, можно применить 
 хук useRef() */

/** useRef - хук, который очень сильно похож на useState, но все же он отличается от него.
 * Он также, как useState, создает состояние, но отличается useRef от useState тем, что изменение аргумента useRef'a не вызывает 
 * повторный рендер, как это происходит в useState'e. \
 * 
 * Переменная, которая создается для useRef - ОБЪЕКТ, поэтому что бы получить его значение, надо добавить ".current"
 * 
 * У useRef также есть возможности, связанные с DOM-деревом, например - мы можем получать ссылки на определенные DOM-элементы
 * 
 * Также useRef очень часто используется для того, чтобы задавать ФОКУСЫ на элементы
 * 
 * Для получения предыдущего значения(до рендера) также можно использовать данный хук. Через useState такое сделать нельзя
 * 
 * 
 * Самое важное что про этот хук надо понять - он сохраняет состояние, но не вызывает рендера.
 */


export function UseRef() {
    const [value, setValue] = useState('start');
    const renderCount = useRef(1); // Начальное значение = 1 (замена 4 строки).

    const inputRef = useRef(null) // Переменная для получения информации из input(значение в нем). По факту сейчас переменная - это
    // поле input, заключенное в переменную, с которым мы можем делать все что угодно через привязку ref={переменная}

    const focus = () => inputRef.current.focus() 
    const nullValue = () => { inputRef.current.value = '' }
    // В результате работы focus после нажатия на кнопку "фокус" наше внимание перейдет на input за счет выделения этого input внешними
    // рамками

    const prevValue = useRef('') // Переменная для отслеживания предыдущего значения состояния(по умолчанию пустая строка - логично)

    // useEffect(() => {
    //     renderCount++;
    // })

    useEffect(() => { // В данном случае мы не вызываем рендер компонента. То есть если мы хотим сохранить что-то между
        // рендерами, и при этом не хотим это перерисовывать, мы используем useRef(), если хотим перерисовывать - useState()
        renderCount.current++;
        console.log(inputRef.current.value) // Каждый раз в консоль выводится значение, находящееся в поле input
    })

    useEffect(() => {
        prevValue.current = value;
    }, [value])
    
    return (
        <div>
            <h1>Hello world!</h1>

            <h2>Количество рендеров: {renderCount.current}</h2>
            <input type="text" value={value} onChange={e => setValue(e.target.value)} ref={inputRef}/>

            <button className="btn btn-success" onClick={focus}>Фокус</button>
            <button className="btn btn-danger" onClick={nullValue}>Очистить строку</button>

            <h2>Прошлое состояние: {prevValue.current}</h2>
        </div>
    )
}