/** Для чего вообще нежны хуки? В чем их смысл? 
 * В React state — это способ хранить и управлять данными внутри компонента, которые могут меняться 
 * со временем и влияют на то, как компонент отображается. Но предназначены они только для классовых компонентов(extends ClassComponent)
 * Со временем React стал предпочитать функциональные компоненты классовым, и перед разработчиками React встала задача интегрировать State
 * в функциональные компоненты. Так появляются ХУКИ - по факту те же state, только для функциональных компонентов. 
 * 
 * 
 *      useState(начальное значение)
 * Предназначен для того, чтобы взаимодействовать со State'ом. Данный хук возвращает КОРТЕЖ(неизменяемый список) из двух элеменов - имя переменной, 
 * куда подставляется значение, поступающее из функции, и сама эта функция, которая является 2 параметром в этом КОРТЕЖЕ. 
 * Допустим при нажатии мы должны изменить значение в переменной на 1:
 * 
 *      const/let [per, func] = useState(0)
 *      console.log(per) // 0
 *      
 *      *что то там* onclick={() => func(prev => prev + 1)}
 *      console.log(per) // 1
 * 
 * В данном коде мы определили переменную с именем per - к ней мы теперь всегда можем обратиться по этому имени - обычная переменная
 * Применяя функцию func при нажатии мы увеличили значение в per на 1. Теперь там значение 1.
 * ПРИ ИЗМЕНЕНИИ СОСТОЯНИЯ ПЕРЕРИСОВЫВЕТСЯ ВЕСЬ СВЯЗАННЫЙ ЭЛЕМЕНТ, поэтому МЫ УВИДИМ изменение на экране, если выводили их
 * 
 * Мы не можем создавать функции/определять состояния внутри блоков if и прочие. Мы должны это делать только во главе нашего компонента
 */

import { useState } from "react"

function randomNum() {
    console.log('Some calculations...') // будет выводится 2 раза. Связано это со Strict mod(в main.jsx). В нем функция вызывается 2 раза для достоверности
    return Math.trunc(Math.random() * 20)
}

export function StateFunc() {
    // let [counter, setCount] = useState(randomNum) // Можно задавать начальное значение так, а можно с помощью стрелочной функции
    let [counter, setCount] = useState(() => { 
        return randomNum();
    });


    const  [object, setObject] = useState({ // Состояние в виде объекта. Встречается довольно редко. Проще сделать просто 2 useState'а и их поменять по отдельности
        title: "Счетчик",
        date: Date.now()
    })

    // const [data, setData] = useState(Date.now())
    // const [title, setTitle] = useState('Новое название')

    // function update() {
    //     setData(Date.now());
    //     setTitle("Новый титульник")
    // }

    function updateTitle() {
        setObject(prev => {
            return {
                ...prev,                 // Добавляем все предыдщее постояние, по сути создаем копию
                title: 'Новое название', // Изменяем нужный нам параметр
                date: Date.now(),
            }
        })  
        // Если бы не было деструктуризации object'а, то после нажатия у нас в переменной стало бы хранится
        // только новое название, ДАТА бы ПРОПАЛА. Поэтому нам надо сначала добавить все, что было в предыдущем
        // object(деструктуризировали), а только потом обновляем
    }

    return (
        <div>
            <h1>Счётчик: {counter}</h1>
            <button className="btn btn-success" onClick={() => setCount(prev => prev + 1)}>Добавить</button>
            <button className="btn btn-danger" onClick={() => setCount(prev => prev - 1)}>Убавить</button>

            <button className="btn btn-warning" onClick={updateTitle}>
                Изменить название
            </button>

            <pre>
                {JSON.stringify(object, null, 2)}
            </pre>
        </div>
    )
}